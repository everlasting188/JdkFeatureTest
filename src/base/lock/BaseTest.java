package base.lock;

/**
 * 
 * 详细解说一下同步方法的锁，同步方法分为静态同步方法与非静态同步方法。
 * 
 * 所有的非静态同步方法用的都是同一把锁――实例对象本身，也就是说如果一个实例对象的非静态同步方法获取锁后，
 * 该实例对象的其他非静态同步方法必须等待获取锁的方法释放锁后才能获取锁，可是别的实例对象的非静态同步方法因为跟该实例对象的非静态同步方法用的是不同的锁，
 * 所以毋须等待该实例对象已获取锁的非静态同步方法释放锁就可以获取他们自己的锁。
 * 
 * 而所有的静态同步方法用的也是同一把锁――类对象本身，这两把锁是两个不同的对象，所以静态同步方法与非静态同步方法之间是不会有竞态条件的。
 * 但是一旦一个静态同步方法获取锁后
 * ，其他的静态同步方法都必须等待该方法释放锁后才能获取锁，而不管是同一个实例对象的静态同步方法之间，还是不同的实例对象的静态同步方法之间
 * ，只要它们同一个类的实例对象！
 * 
 * 而对于同步块，由于其锁是可以选择的，所以只有使用同一把锁的同步块之间才有着竞态条件，这就得具体情况具体分析了，但这里有个需要注意的地方，
 * 同步块的锁是可以选择的
 * ，但是不是可以任意选择的！！！！这里必须要注意一个物理对象和一个引用对象的实例变量之间的区别！使用一个引用对象的实例变量作为锁并不是一个好的选择
 * ，因为同步块在执行过程中可能会改变它的值
 * ，其中就包括将其设置为null，而对一个null对象加锁会产生异常，并且对不同的对象加锁也违背了同步的初衷！这看起来是很清楚的
 * ，但是一个经常发生的错误就是选用了错误的锁对象
 * ，因此必须注意：同步是基于实际对象而不是对象引用的！多个变量可以引用同一个对象，变量也可以改变其值从而指向其他的对象
 * ，因此，当选择一个对象锁时，我们要根据实际对象而不是其引用来考虑！作为一个原则，不要选择一个可能会在锁的作用域中改变值的实例变量作为锁对象！！！！
 * 
 * 
 * 本类除测试同步类、同步方法、同步对象的区别
 */
public class BaseTest {
	
	
	
	public static void main(String[] args) {
		
	}

}
